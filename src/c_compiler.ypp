%{
	#include <time.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <memory>
	#include "../src/symboltable.h"
	#include "../src/tree/tree.h"
	#include "../src/tree/labelNode.h"
	#include "../src/tree/emptyNode.h"
	#include "../src/tree/iteration_statement.h"
	#include "../src/tree/dataNode.h"
	#include "../src/tree/jumpNode.h"
	#include "../src/tree/selectionNode.h"
	#include "../src/tree/operatorNode.h"
	#include "../src/tree/assignmentNode.h"
	#include "../src/tree/relationNode.h"
	#include "../src/tree/castNode.h"
	#include "../src/tree/functionNode.h"
	#include "../src/tree/typeNode.h"
	#include "../src/tree/declarationSpecNode.h"


	#define MAX_LINE_LENGTH 500
	FILE *out_log;
	FILE *outfile;
	FILE *errorText;
	FILE * tokenFile;
	FILE * parseFile;
	//FILE * productionFile;
	int insert_lookup = 0;//1 lookup 0 insert
	char *logName = (char*)"testCases/compilerLog.txt";
	char *file_name;
	time_t time_time;
	clock_t clock_time;
	int currentCodeLine = 0;

	/**
	 * SymbolTable and variables to manipulate the insertion to symbol table
	 */
	bool isParam = false;
	SymbolTable s("Symbol Table");
	SymbolTable astTable("AST Table");

	vector<vector<nodeDataType>> paramTypesToBeUsed = {};

	int levels[5];

	extern char yytext[];
	
	Tree AST;
	int AST_node_counter;
	int Label_counter;
	int Variable_counter;

	unique_ptr<Node> variableToInsert(new Node());
	unique_ptr<Node> parameterToInsert(new Node());

	extern int column;
	extern int line;
	extern int size;
	TreeNode* scopeInits;
	EmptyNode* blank;
	

	void outputReduction(const char *s);
	char* getLine();
	void yyerror(char const *msg);

	int yylex();

	string getDataTypeString(nodeDataType);
	TreeNode* createOperatorDataNode(OperatorType opType, TreeNode *leftChil, TreeNode* rightChild);
	TreeNode* createRelationNode(OperatorType opType, TreeNode *leftChild, TreeNode *rightChild);
	nodeDataType typeCheck(OperatorType opType,TreeNode **leftChild, TreeNode **rightChild);
	void implicitCastWarning(nodeDataType t1, nodeDataType t2);
	string codeLine();

%}
%define parse.error verbose
%token AUTO_tok
%token BREAK_tok
%token CASE_tok
%token CHAR_tok
%token CONST_tok
%token CONTINUE_tok
%token DEFAULT_tok
%token DO_tok
%token DOUBLE_tok
%token ELSE_tok
%token ENUM_tok
%token EXTERN_tok
%token FLOAT_tok
%token FOR_tok
%token GOTO_tok
%token IF_tok
%token INT_tok
%token LONG_tok
%token REGISTER_tok
%token RETURN_tok
%token SHORT_tok
%token SIGNED_tok
%token SIZEOF_tok
%token STATIC_tok
%token STRUCT_tok
%token SWITCH_tok
%token TYPEDEF_tok
%token UNION_tok
%token UNSIGNED_tok
%token VOID_tok
%token VOLATILE_tok
%token WHILE_tok
%token ERROR_tok
%token ID_tok
%token PLUS_tok
%token MINUS_tok
%token STAR_tok
%token SEMI_tok
%token OPEN_BRACKET_tok
%token CLOSE_BRACKET_tok
%token EQUAL_tok
%token COLON_tok
%token COMMA_tok
%token OPEN_PAREN_tok
%token CLOSE_PAREN_tok
%token OPEN_BRACE_tok
%token CLOSE_BRACE_tok
%token QUESTION_MARK_tok
%token BAR_tok
%token CARET_tok
%token AMP_tok
%token GT_tok
%token LT_tok
%token PERCENT_tok
%token TILDA_tok
%token NOT_tok
%token INC_OP_tok
%token DEC_OP_tok
%token INTEGER_CONSTANT_tok
%token FLOATING_CONSTANT_tok

%token CHARACTER_CONSTANT_tok
%token ENUMERATION_CONSTANT_tok
%token STRING_LITERAL_tok

%token PTR_OP_tok
%token LEFT_OP_tok
%token RIGHT_OP_tok
%token LE_OP_tok
%token GE_OP_tok
%token EQ_OP_tok
%token NE_OP_tok
%token AND_OP_tok
%token OR_OP_tok
%token MULT_ASSIGN_tok
%token DIV_ASSIGN_tok
%token MOD_ASSIGN_tok
%token ADD_ASSIGN_tok
%token SUB_ASSIGN_tok
%token LEFT_ASSIGN_tok
%token RIGHT_ASSIGN_tok
%token AND_ASSIGN_tok
%token XOR_ASSIGN_tok
%token OR_ASSIGN_tok
%token TYPEDEF_NAME_tok
%token ELIPSIS_tok
%token DIV_tok
%token PERIOD_tok

%union
{
	int lint;
	char lchar;
	char* lstr;
	double ldoub;
	class Node* lnode;
	class TreeNode* tnode;

	int aType;

}

%right THEN
%right ELSE_tok

%start translation_unit
%%

translation_unit
	: external_declaration {
		TreeNode* tmp = new TreeNode("translation_unit_",1);
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		AST.set_root(tmp);
		outputReduction("translation_unit : external_declaration");}
	| translation_unit external_declaration {
		TreeNode* tmp = new TreeNode("translation_unit_",2);
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		AST.set_root(tmp);
		outputReduction("translation_unit : translation_unit external_declaration");}
	;

external_declaration
	: function_definition {
		s.popUntilGlobal();
		$<tnode>$ = $<tnode>1;
		outputReduction("external_declaration : function_definition");}
	| declaration {
		s.popUntilGlobal();
		$<tnode>$ = $<tnode>1;
		outputReduction("external_declaration : declaration");}
	;

function_definition
	: declarator compound_statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		FunctionNode* tmp = new FunctionNode("function_definition_");
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		tmp->assignChild(0,blank1);
		tmp->assignChild(1,$<tnode>1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(3,$<tnode>2);
		tmp->errorCheck("");
		$<tnode>$ = tmp;
		outputReduction("function_definition : declarator compound_statement");}
	| declarator   declaration_list {insert_lookup=1;}  compound_statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		FunctionNode* tmp = new FunctionNode("function_definition_");
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		tmp->assignChild(0,blank1);
		tmp->assignChild(1,$<tnode>1);
		tmp->assignChild(2,$<tnode>2);
		tmp->assignChild(3,$<tnode>4);
		tmp->errorCheck("");
		$<tnode>$ = tmp;
		outputReduction("function_definition : declarator declaration_list compound_statement");}
	| declaration_specifiers declarator compound_statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		FunctionNode* tmp = new FunctionNode("function_definition_");
		
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		//tmp->assignLine(3,1,1,"test");
		//cout<<"Here"<<endl;
		//cout.flush();
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		tmp->assignChild(2,blank1);
		tmp->assignChild(3,$<tnode>3);
		tmp->errorCheck("");
		$<tnode>$ = tmp;
		outputReduction("function_definition : declaration_specifiers declarator compound_statement");}
	| declaration_specifiers declarator   declaration_list {insert_lookup=1;} compound_statement {
		FunctionNode* tmp = new FunctionNode("function_definition_");
		tmp->assignLine(line,column,column,$<tnode>1->coldLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		tmp->assignChild(2,$<tnode>3);
		tmp->assignChild(3,$<tnode>5);
		tmp->errorCheck("");
		$<tnode>$ = tmp;
		outputReduction("function_definition : declaration_specifiers declarator declaration_list compound_statement");}
	;

declaration
	: declaration_specifiers SEMI_tok {
		TypeNode* tmp = new TypeNode("declaration_",1);
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("declaration : declaration_specifiers SEMI_tok");}
	| declaration_specifiers init_declarator_list SEMI_tok {
		TypeNode* tmp = new TypeNode("declaration_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		//cout << "Type node" << $<tnode>1->getArrayOffset() << " " << $<tnode>2->getArrayOffset() << endl;
		char buffer[500];
		vector<nodeDataType> types = tmp->getType();
		tmp->parseTypes();
		// Debugging: Get the types parsed
		// for (int t : types) {
		// 	cout << getDataTypeString(static_cast<nodeDataType>(t)) << " ";
		// } cout << endl;
		$<tnode>$ = tmp;
		outputReduction("declaration : declaration_specifiers init_declarator_list SEMI_tok");}

declaration_list
	: declaration {
		$<tnode>$ = $<tnode>1;
		outputReduction("declaration_list : declaration");}

	|  declaration_list declaration {
		TreeNode* tmp = new TreeNode("declaration_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("declaration_list : declaration_list declaration");}
	;

declaration_specifiers
	: storage_class_specifier {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",1);
		tmp->assignChild(0, $<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : storage_class_specifier");}
	| storage_class_specifier declaration_specifiers {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : storage_class_specifier declaration_specifiers");}
	| type_specifier {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",1);
		tmp->assignChild(0, $<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : type_specifier");}
	| type_specifier declaration_specifiers {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : type_specifier declaration_specifiers");}
	| type_qualifier {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",1);
		tmp->assignChild(0, $<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : type_qualifier");}
	| type_qualifier declaration_specifiers {
		DeclarationSpecNode* tmp = new DeclarationSpecNode("declaration_specifiers_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("declaration_specifiers : type_qualifier declaration_specifiers");}
	;

storage_class_specifier
	: AUTO_tok {
		DataNode* tmp = new DataNode("storage_class_specifier_");
		tmp->setTypeSpecifier(AUTO_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("storage_class_specifier : AUTO_tok");}
	| REGISTER_tok {
		DataNode* tmp = new DataNode("storage_class_specifier_");
		tmp->setTypeSpecifier(REGISTER_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("storage_class_specifier : REGISTER_tok");}
	| STATIC_tok {
		DataNode* tmp = new DataNode("storage_class_specifier_");
		tmp->setTypeSpecifier(STATIC_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("storage_class_specifier : STATIC_tok");}
	| EXTERN_tok {
		DataNode* tmp = new DataNode("storage_class_specifier_");
		tmp->setTypeSpecifier(EXTERN_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("storage_class_specifier : EXTERN_tok");}
	| TYPEDEF_tok {
		DataNode* tmp = new DataNode("storage_class_specifier_");
		tmp->setTypeSpecifier(TYPEDEF_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("storage_class_specifier : TYPEDEF_tok");}
	;

type_specifier
	: VOID_tok {
		variableToInsert->types.push_back(VOID_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(VOID_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : VOID_tok");}
	| CHAR_tok {
		variableToInsert->types.push_back(CHAR_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(CHAR_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : CHAR_tok");}
	| SHORT_tok { 
		variableToInsert->types.push_back(SHORT_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(SHORT_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : SHORT_tok");}
	| INT_tok {
		variableToInsert->types.push_back(INT_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : INT_tok");}
	| LONG_tok {
		variableToInsert->types.push_back(LONG_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(LONG_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : LONG_tok");}
	| FLOAT_tok {
		variableToInsert->types.push_back(DOUBLE_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(FLOAT_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : FLOAT_tok");}
	| DOUBLE_tok {
		variableToInsert->types.push_back(DOUBLE_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(DOUBLE_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : DOUBLE_tok");}
	| SIGNED_tok {
		variableToInsert->types.push_back(SIGNED_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(SIGNED_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : SIGNED_tok");}
	| UNSIGNED_tok {
		variableToInsert->types.push_back(UNSIGNED_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(UNSIGNED_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : UNSIGNED_tok");}
	| struct_or_union_specifier { 
		$<tnode>$ = $<tnode>1;
		outputReduction("type_specifier : struct_or_union_specifier");}
	| ENUM_tok { 
		variableToInsert->types.push_back(ENUM_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->setTypeSpecifier(ENUM_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : ENUM_tok");}
	| TYPEDEF_NAME_tok {
		variableToInsert->types.push_back(TYPEDEF_TYPE_NODE);

		DataNode* tmp = new DataNode("type_specifier_");
		tmp->storeString(yylval.lstr);
		tmp->setTypeSpecifier(TYPEDEF_NAME_TYPE_NODE);
		tmp->notData();
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_specifier : TYPEDEF_NAME_tok");}
	;

type_qualifier
	: CONST_tok {
		variableToInsert->types.push_back(CONST_TYPE_NODE);

		DataNode* tmp = new DataNode("type_qualifier_");
		tmp->setTypeSpecifier(CONST_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_qualifier : CONST_tok");}
	| VOLATILE_tok {
		variableToInsert->types.push_back(VOLATILE_TYPE_NODE);

		DataNode* tmp = new DataNode("type_qualifier_");
		tmp->setTypeSpecifier(VOLATILE_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("type_qualifier : VOLATILE_tok");}
	;

struct_or_union_specifier
	: struct_or_union identifier OPEN_BRACE_tok   struct_declaration_list   CLOSE_BRACE_tok {
		TreeNode* tmp = new TreeNode("struct_or_union_specifier_",3);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		tmp->assignChild(2,$<tnode>4);
		$<tnode>$ = tmp;
		outputReduction("struct_or_union_specifier : struct_or_union identifier OPEN_BRACE_tok struct_declaration_list CLOSE_BRACE_tok");}
	| struct_or_union OPEN_BRACE_tok   struct_declaration_list   CLOSE_BRACE_tok {
		TreeNode* tmp = new TreeNode("struct_or_union_specifier_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("struct_or_union_specifier : struct_or_union OPEN_BRACE_tok struct_declaration_list CLOSE_BRACE_tok");}
	| struct_or_union identifier {
		TreeNode* tmp = new TreeNode("struct_or_union_specifier_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("struct_or_union_specifier : struct_or_union identifier");}
	;

struct_or_union
	: STRUCT_tok {
		DataNode* tmp = new DataNode("struct_or_union_");
		tmp->setTypeSpecifier(STRUCT_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("struct_or_union : STRUCT_tok");}
	| UNION_tok {
		DataNode* tmp = new DataNode("struct_or_union_");
		tmp->setTypeSpecifier(UNION_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("struct_or_union : UNION_tok");}
	;

struct_declaration_list
	: struct_declaration {
		$<tnode>$ = $<tnode>1;
		outputReduction("struct_declaration_list : struct_declaration");}
	| struct_declaration_list struct_declaration {
		TreeNode* tmp = new TreeNode("struct_declaration_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("struct_declaration_list : struct_declaration_list struct_declaration");}
	;

init_declarator_list
	: init_declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("init_declarator_list : init_declarator");}
	| init_declarator_list COMMA_tok init_declarator {
		TreeNode* tmp = new TreeNode("init_declarator_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("init_declarator_list : init_declarator_list COMMA_tok init_declarator");}
	;

init_declarator
	: declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("init_declarator : declarator");}
	| declarator EQUAL_tok initializer {
		AssignmentNode* tmpAssign = new AssignmentNode("scope_assignment_",2);
		tmpAssign->setAssignType(EQUAL_ASSIGN);
		tmpAssign->assignChild(0,$<tnode>1);
		tmpAssign->assignChild(1,$<tnode>3);
		tmpAssign->errorCheck();
		if(scopeInits->checkChildZ()==true)
		{
			scopeInits->assignChild(0,tmpAssign);
		}
		else{
			TreeNode* ntmp = new TreeNode("scope_inits",2);
			ntmp->assignChild(0,scopeInits);
			ntmp->assignChild(1,tmpAssign);
			scopeInits = ntmp;
		}
		//scopeInits->assignChild(0,tmpAssign);
		//TreeNode* tmp = new TreeNode("init_declarator_",2);
		//tmp->assignLine(line,column-size,column,codeLine());
		//tmp->assignChild(0,$<tnode>1);
		//tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = $<tnode>1;
		outputReduction("init_declarator : declarator EQUAL_tok initializer");}
	;

struct_declaration
	: specifier_qualifier_list struct_declarator_list SEMI_tok {
		TreeNode* tmp = new TreeNode("struct_declaration_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("struct_declaration : specifier_qualifier_list struct_declarator_list SEMI_tok");}
	;

specifier_qualifier_list
	: type_specifier {
		$<tnode>$ = $<tnode>1;
		outputReduction("specifier_qualifier_list : type_specifier");}
	| type_specifier specifier_qualifier_list {
		TreeNode* tmp = new TreeNode("specifier_qualifier_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("specifier_qualifier_list : type_specifier specifier_qualifier_list");}
	| type_qualifier {
		$<tnode>$ = $<tnode>1;
		outputReduction("specifier_qualifier_list : type_qualifier");}
	| type_qualifier specifier_qualifier_list {
		TreeNode* tmp = new TreeNode("specifier_qualifier_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("specifier_qualifier_list : type_qualifier specifier_qualifier_list");}
	;

struct_declarator_list
	: struct_declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("struct_declarator_list : struct_declarator");}
	| struct_declarator_list COMMA_tok struct_declarator {
		TreeNode* tmp = new TreeNode("specifier_qualifier_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("struct_declarator_list : struct_declarator_list COMMA_tok struct_declarator");}
	;

struct_declarator
	: declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("struct_declarator : declarator");}
	| COLON_tok constant_expression {
		TreeNode* tmp = new TreeNode("struct_declarator_",1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("struct_declarator : COLON_tok constant_expression");}
	| declarator COLON_tok constant_expression {
		TreeNode* tmp = new TreeNode("struct_declarator_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("struct_declarator : declarator COLON_tok constant_expression");}
	;

declarator
	: direct_declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("declarator : direct_declarator");}
	| pointer direct_declarator {
		TreeNode* tmp = new TreeNode("declarator_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("declarator :  pointer direct_declarator");}
	;

__isParam__
	:	{
			isParam = true;
			s.pushEmptyBST();
		}
	;
	

direct_declarator
	: identifier {
		$<tnode>$ = $<tnode>1;
		Node* searchResult = s.searchBottom(variableToInsert->name);
		if (isParam) {
			if (parameterToInsert->name != "") {
				parameterToInsert->types = variableToInsert->types;
				//parameterToInsert->ticketNumber = $<tnode>1->returnTicket();
				s.insert(parameterToInsert->name, *parameterToInsert);
				parameterToInsert.reset(new Node());
			}
		} else {
			Node* searchResult = s.searchTop(variableToInsert->name);
			if (searchResult == NULL || searchResult->ntype != FUNCTION) {
				variableToInsert->ticketNumber = $<tnode>1->returnTicket();
				s.insert(variableToInsert->name, *variableToInsert);
			}
			variableToInsert->types = {};
		}

		outputReduction("direct_declarator : identifier");}
	| OPEN_PAREN_tok declarator CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : OPEN_PAREN_tok declarator CLOSE_PAREN_tok");}
	| direct_declarator OPEN_BRACKET_tok CLOSE_BRACKET_tok {
		// cout << variableToInsert->name << endl;
		TreeNode* tmp = new TreeNode("direct_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : direct_declarator OPEN_BRACKET_tok CLOSE_BRACKET_tok");}
	| direct_declarator OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok {
		// cout << variableToInsert->name << endl;
		
		DataNode* tmp = new DataNode("direct_declarator_");
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		tmp->notData();
		tmp->setOperator(BRACKET_OP);
		char buffer[500];
		$<tnode>3->getDataType(buffer);
		//cout << atoi(buffer) << endl;
		if(atoi(buffer) <= 0)
			tmp->TreeNode::errorCheck("ERROR: Invalid array size in declaration");
		tmp->setArrayOffset(atoi(buffer) * $<tnode>1->getArrayOffset());
		//cout << tmp->getArrayOffset() << endl;
		tmp->setTypeSpecifier(ID_TYPE_NODE);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : direct_declarator OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok");}

	| direct_declarator __isParam__ OPEN_PAREN_tok CLOSE_PAREN_tok {

		isParam = false;

		Node* searchResult = s.searchBottom(variableToInsert->name);
		if (searchResult != NULL) {
			searchResult->ntype = FUNCTION;
		}
		paramTypesToBeUsed = {};

		TreeNode* tmp = new TreeNode("direct_declarator_",2);
		EmptyNode* blank1 = new EmptyNode("empty_");
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setTypeSpecifier(DIRECT_DECL_TYPE_NODE);

		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,blank1);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : direct_declarator OPEN_PAREN_tok CLOSE_PAREN_tok");}
	| direct_declarator __isParam__ OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok {
		isParam = false;
		int scope;
		Node* searchResult = s.searchBottom(variableToInsert->name);
		if (searchResult != NULL) {
			searchResult->ntype = FUNCTION;
			searchResult->params = paramTypesToBeUsed;
		}
		paramTypesToBeUsed = {};
		
		TreeNode* tmp = new TreeNode("direct_declarator_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setTypeSpecifier(DIRECT_DECL_TYPE_NODE);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>4);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : direct_declarator OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok");}
	| direct_declarator __isParam__ OPEN_PAREN_tok identifier_list CLOSE_PAREN_tok {
		isParam = false;
	
		Node* searchResult = s.searchBottom(variableToInsert->name);
		if (searchResult != NULL && searchResult->ntype == FUNCTION) {
			searchResult->ntype = FUNCTION;
		}

		TreeNode* tmp = new TreeNode("direct_declarator_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setTypeSpecifier(DIRECT_DECL_TYPE_NODE);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>4);
		$<tnode>$ = tmp;
		outputReduction("direct_declarator : direct_declarator OPEN_PAREN_tok identifier_list CLOSE_PAREN_tok");}
	;

pointer
	: STAR_tok {
		variableToInsert->types.push_back(POINTER_TYPE_NODE);
		DataNode* tmp = new DataNode("pointer_");
		tmp->setTypeSpecifier(POINTER_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("pointer : STAR_tok");}
	| STAR_tok type_qualifier_list {
		variableToInsert->types.push_back(POINTER_TYPE_NODE);

		TreeNode* tmp = new TreeNode("pointer_",1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("pointer : STAR_tok type_qualifier_list");}
	| STAR_tok pointer {
		variableToInsert->types.push_back(POINTER_TYPE_NODE);

		TreeNode* tmp = new TreeNode("pointer_",1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("pointer : STAR_tok pointer");}
	| STAR_tok type_qualifier_list pointer {
		variableToInsert->types.push_back(POINTER_TYPE_NODE);

		TreeNode* tmp = new TreeNode("pointer_",2);
		tmp->assignChild(0,$<tnode>2);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("pointer : STAR_tok type_qualifier_list pointer");}
	;

type_qualifier_list
	: type_qualifier {
		$<tnode>$ = $<tnode>1;
		outputReduction("type_qualifier_list : type_qualifier");}
	| type_qualifier_list type_qualifier {
		TreeNode* tmp = new TreeNode("type_qualifier_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("type_qualifier_list : type_qualifier_list type_qualifier");}
	;

parameter_type_list
	: parameter_list {
		$<tnode>$ = $<tnode>1;
		outputReduction("parameter_type_list : parameter_list");}
	| parameter_list COMMA_tok ELIPSIS_tok {
		/*TreeNode* tmp = new TreeNode("parameter_type_list_",1);
		tmp->assignLine(line,column-size,column,errorText);
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		functionality of this type not supported, thus ignored*/
		$<tnode>$ = $<tnode>1;
		outputReduction("parameter_type_list : parameter_list COMMA_tok ELIPSIS_tok");}
	;

parameter_list
	: parameter_declaration {
		EmptyNode* blank1 = new EmptyNode("empty_");
		ParamListNode* tmp = new ParamListNode("parameter_type_list_",false);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,blank1);
		$<tnode>$ = tmp;
		outputReduction("parameter_list : parameter_declaration");}
	| parameter_list COMMA_tok parameter_declaration {
		ParamListNode* tmp = new ParamListNode("parameter_list_",false);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("parameter_list : parameter_list COMMA_tok parameter_declaration");}
	;

parameter_declaration
	: declaration_specifiers declarator {
		parameterToInsert->types = variableToInsert->types;
		paramTypesToBeUsed.push_back(parameterToInsert->types);
		variableToInsert->types = {};

		TreeNode* tmp = new TreeNode("parameter_declaration_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("parameter_declaration : declaration_specifiers declarator");}
	| declaration_specifiers {
		parameterToInsert->types = variableToInsert->types;
		paramTypesToBeUsed.push_back(parameterToInsert->types);
		variableToInsert->types = {};
		
		$<tnode>$ = $<tnode>1;
		outputReduction("parameter_declaration : declaration_specifiers");}
	| declaration_specifiers abstract_declarator {
		TreeNode* tmp = new TreeNode("parameter_declaration_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("parameter_declaration : declaration_specifiers abstract_declarator");}
	;

identifier_list
	: identifier {
		EmptyNode* blank1 = new EmptyNode("empty_");
		ParamListNode* tmp = new ParamListNode("identifier_list_",true);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,blank1);
		$<tnode>$ = $<tnode>1;
		outputReduction("identifier_list : identifier");}
	| identifier_list COMMA_tok identifier {
		ParamListNode* tmp = new ParamListNode("identifier_list_",true);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("identifier_list : identifier_list COMMA_tok identifier");}
	;

initializer
	: assignment_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("initializer : assignment_expression");}
	| OPEN_BRACE_tok initializer_list CLOSE_BRACE_tok {
		TreeNode* tmp = new TreeNode("initializer_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("initializer : OPEN_BRACE_tok initializer_list CLOSE_BRACE_tok");}
	| OPEN_BRACE_tok initializer_list COMMA_tok CLOSE_BRACE_tok {
		TreeNode* tmp = new TreeNode("initializer_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("initializer : OPEN_BRACE_tok initializer_list COMMA_tok CLOSE_BRACE_tok");}
	;

initializer_list
	: initializer {
		$<tnode>$ = $<tnode>1;
		outputReduction("initializer_list : initializer");}
	| initializer_list COMMA_tok initializer {
		TreeNode* tmp = new TreeNode("initializer_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("initializer_list : initializer_list COMMA_tok initializer");}
	;

type_name
	: specifier_qualifier_list {
		$<tnode>$ = $<tnode>1;
		outputReduction("type_name : specifier_qualifier_list");}
	| specifier_qualifier_list abstract_declarator {
		TreeNode* tmp = new TreeNode("type_name_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("type_name : specifier_qualifier_list abstract_declarator");}
	;

abstract_declarator
	: pointer {
		$<tnode>$ = $<tnode>1;
		outputReduction("abstract_declarator : pointer");}
	| direct_abstract_declarator {
		$<tnode>$ = $<tnode>1;
		outputReduction("abstract_declarator : direct_abstract_declarator");}
	| pointer direct_abstract_declarator {
		TreeNode* tmp = new TreeNode("abstract_declarator_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("abstract_declarator : pointer direct_abstract_declarator");}
	;

direct_abstract_declarator
	: OPEN_PAREN_tok abstract_declarator CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : OPEN_PAREN_tok abstract_declarator CLOSE_PAREN_tok");}
	| OPEN_BRACKET_tok CLOSE_BRACKET_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",0);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : OPEN_BRACKET_tok CLOSE_BRACKET_tok");}
	| OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok");}
	| direct_abstract_declarator OPEN_BRACKET_tok CLOSE_BRACKET_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : direct_abstract_declarator OPEN_BRACKET_tok CLOSE_BRACKET_tok");}
	| direct_abstract_declarator OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : direct_abstract_declarator OPEN_BRACKET_tok constant_expression CLOSE_BRACKET_tok");}
	| OPEN_PAREN_tok CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",0);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : OPEN_PAREN_tok CLOSE_PAREN_tok");}
	| OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok");}
	| direct_abstract_declarator OPEN_PAREN_tok CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : direct_abstract_declarator OPEN_PAREN_tok CLOSE_PAREN_tok");}
	| direct_abstract_declarator OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("direct_abstract_declarator_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("direct_abstract_declarator : direct_abstract_declarator OPEN_PAREN_tok parameter_type_list CLOSE_PAREN_tok");}
	;

statement
	: labeled_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : labeled_statement");}
	| compound_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : compound_statement");}
	| expression_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : expression_statement");}
	| selection_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : selection_statement");}
	| iteration_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : iteration_statement");}
	| jump_statement {
		$<tnode>$ = $<tnode>1;
		outputReduction("statement : jump_statement");}
	;

labeled_statement
	: identifier COLON_tok statement {
		LabelNode* tmp = new LabelNode("labeled_statement_");
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("labeled_statement : identifier COLON_tok statement");}
	| CASE_tok constant_expression COLON_tok statement {
		LabelNode* tmp = new LabelNode("labeled_statement_");

		tmp->assignChild(0,$<tnode>2);

		tmp->assignChild(1,$<tnode>4);

		$<tnode>$ = tmp;
		outputReduction("labeled_statement : CASE_tok constant_expression COLON_tok statement");}
	| DEFAULT_tok COLON_tok statement {
		DataNode* defaultString = new DataNode("default_");
		defaultString->storeString((char *)"default");
		defaultString->assignLine(line,column-8,column,codeLine());
		LabelNode* tmp = new LabelNode("labeled_statement_");
		tmp->assignChild(0,defaultString);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("labeled_statement : DEFAULT_tok COLON_tok statement");}
	;

expression_statement
	: SEMI_tok {
		TreeNode* tmp = new TreeNode("expression_statement_",0);
		tmp->assignLine(line,column-size,column,codeLine());

		$<tnode>$ = tmp;
		outputReduction("expression_statement : SEMI_tok");}
	| expression SEMI_tok {
		$<tnode>$ = $<tnode>1;
		outputReduction("expression_statement : expression SEMI_tok");}
	;

__push__
	:	{
		 s.pushEmptyBST(); 
		}
	;

__pop__
	:	{
			s.popBST();
		}
	;

__setInsert__
	:	{
			insert_lookup = 0;
		}
	;

// Not needed (for now)
// __setLookup__
// 	:	{
// 			insert_lookup = 1;
// 		}
// 	;


compound_statement
	: OPEN_BRACE_tok __push__ CLOSE_BRACE_tok __pop__ {
		TreeNode* tmp = new TreeNode("compound_statement_",0);
		//tmp->assignLine(line,column-size,column,codeLine());

		$<tnode>$ = tmp;
		outputReduction("compound_statement : OPEN_BRACE_tok CLOSE_BRACE_tok");}
	| OPEN_BRACE_tok __push__ statement_list CLOSE_BRACE_tok __pop__ {
		$<tnode>$ = $<tnode>3;
		outputReduction("compound_statement : OPEN_BRACE_tok statement_list CLOSE_BRACE_tok");}
	| OPEN_BRACE_tok __push__ __setInsert__ declaration_list CLOSE_BRACE_tok __pop__ {
		TreeNode* dtmp = new TreeNode("declaration_list_",2);
		dtmp->assignChild(0,$<tnode>4);
		dtmp->assignChild(1,scopeInits);
		scopeInits = new TreeNode("scope_inits",1);
		scopeInits->assignChild(0,blank);
		insert_lookup = 1;
		$<tnode>$ = dtmp;
		outputReduction("compound_statement : OPEN_BRACE_tok declaration_list CLOSE_BRACE_tok");}
	| OPEN_BRACE_tok __push__ __setInsert__ declaration_list {insert_lookup = 1;} statement_list CLOSE_BRACE_tok __pop__ {
		
		TreeNode* tmp = new TreeNode("compound_statement_",2);
		//tmp->assignLine(line,column-size,column,codeLine());
		TreeNode* dtmp = new TreeNode("declaration_list_",2);
		dtmp->assignChild(0,$<tnode>4);
		dtmp->assignChild(1,scopeInits);
		scopeInits = new TreeNode("scope_inits",1);
		scopeInits->assignChild(0,blank);
		tmp->assignChild(0,dtmp);
		
		tmp->assignChild(1,$<tnode>6);
		$<tnode>$ = tmp;
		outputReduction("compound_statement : OPEN_BRACE_tok declaration_list statement_list CLOSE_BRACE_tok");}
	;

statement_list
	: statement {
		insert_lookup = 1;
		int scope;
		Node* searchResult = s.searchAll(variableToInsert->name, &scope);
		if (searchResult == NULL) {
			yyerror("Variable not declared before use");
		}
		

		$<tnode>$ = $<tnode>1;
		outputReduction("statement_list : statement");}
	| statement_list statement {
		insert_lookup = 1;
		int scope;
		Node* searchResult = s.searchAll(variableToInsert->name, &scope);
		if (searchResult == NULL) {
			yyerror("Variable not found");
		}
		

		TreeNode* tmp = new TreeNode("statement_list_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("statement_list : statement_list statement");}
	;

selection_statement
	: IF_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement %prec THEN  {
		SelectionNode* tmp = new SelectionNode("selection_statement_",false);
		EmptyNode* blank1 = new EmptyNode("empty_");
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(2,blank1);
		$<tnode>$ = tmp;
		outputReduction("selection_statement : IF_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement");}
	| IF_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement ELSE_tok statement {
		SelectionNode* tmp = new SelectionNode("selection_statement_",false);
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(2,$<tnode>7);
		$<tnode>$ = tmp;
		outputReduction("selection_statement : IF_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement ELSE_tok statement");}
	| SWITCH_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement {
		SelectionNode* tmp = new SelectionNode("selection_statement_",true);
		EmptyNode* blank1 = new EmptyNode("empty_");
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(2,blank1);
		$<tnode>$ = tmp;
		outputReduction("selection_statement : SWITCH_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement");}
	;

iteration_statement
	: WHILE_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,blank1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(1,$<tnode>3);
		tmp->assignChild(3,$<tnode>5);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : WHILE_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok statement");}
	| DO_tok statement WHILE_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok SEMI_tok {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",true);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,blank1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(3,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : DO_tok statement WHILE_tok OPEN_PAREN_tok expression CLOSE_PAREN_tok SEMI_tok");}
	| FOR_tok OPEN_PAREN_tok SEMI_tok SEMI_tok CLOSE_PAREN_tok statement {
		EmptyNode* blank1 =  new EmptyNode("empty_");
		EmptyNode* blank2 =  new EmptyNode("empty_");
		EmptyNode* blank3 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,blank1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(1,blank3);
		tmp->assignChild(3,$<tnode>6);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok SEMI_tok SEMI_tok CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok SEMI_tok SEMI_tok expression CLOSE_PAREN_tok statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,blank1);
		tmp->assignChild(1,blank2);
		tmp->assignChild(2,$<tnode>5);
		tmp->assignChild(3,$<tnode>7);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok SEMI_tok SEMI_tok expression CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok SEMI_tok expression SEMI_tok CLOSE_PAREN_tok statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,blank1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(1,$<tnode>4);
		tmp->assignChild(3,$<tnode>7);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok SEMI_tok expression SEMI_tok CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok SEMI_tok expression SEMI_tok expression CLOSE_PAREN_tok statement {
		EmptyNode* blank1 =  new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,blank1);
		tmp->assignChild(1,$<tnode>4);
		tmp->assignChild(2,$<tnode>6);
		tmp->assignChild(3,$<tnode>8);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok SEMI_tok expression SEMI_tok expression CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok expression SEMI_tok SEMI_tok CLOSE_PAREN_tok statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		EmptyNode* blank2 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(1,blank1);
		tmp->assignChild(2,blank2);
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(3,$<tnode>7);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok expression SEMI_tok SEMI_tok CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok expression SEMI_tok SEMI_tok expression CLOSE_PAREN_tok statement {
		EmptyNode* blank1 =  new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(1,blank1);
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(2,$<tnode>6);
		tmp->assignChild(3,$<tnode>8);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok expression SEMI_tok SEMI_tok expression CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok expression SEMI_tok expression SEMI_tok CLOSE_PAREN_tok statement {
		EmptyNode* blank1 = new EmptyNode("empty_");
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(2,blank1);
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(3,$<tnode>8);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok expression SEMI_tok expression SEMI_tok CLOSE_PAREN_tok statement");}
	| FOR_tok OPEN_PAREN_tok expression SEMI_tok expression SEMI_tok expression CLOSE_PAREN_tok statement {
		Iter_statement* tmp = new Iter_statement("iteration_statement_",false);
		tmp->assignChild(0,$<tnode>3);
		tmp->assignChild(1,$<tnode>5);
		tmp->assignChild(2,$<tnode>7);
		tmp->assignChild(3,$<tnode>9);
		$<tnode>$ = tmp;
		outputReduction("iteration_statement : FOR_tok OPEN_PAREN_tok expression SEMI_tok expression SEMI_tok expression CLOSE_PAREN_tok statement");}
	;

jump_statement
	: GOTO_tok identifier SEMI_tok {
		JumpNode* tmp = new JumpNode("jump_statement_",0);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("jump_statement : GOTO_tok identifier SEMI_tok");}
	| CONTINUE_tok SEMI_tok {
		JumpNode* tmp = new JumpNode("jump_statement_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		
		$<tnode>$ = tmp;
		outputReduction("jump_statement : CONTINUE_tok SEMI_tok");}
	| BREAK_tok SEMI_tok {
		JumpNode* tmp = new JumpNode("jump_statement_",2);
		tmp->assignLine(line,column-size,column,codeLine());
		
		$<tnode>$ = tmp;
		outputReduction("jump_statement : BREAK_tok SEMI_tok");}
	| RETURN_tok SEMI_tok {
		JumpNode* tmp = new JumpNode("jump_statement_",3);
		tmp->assignLine(line,column-size,column,codeLine());
		
		$<tnode>$ = tmp;
		outputReduction("jump_statement : RETURN_tok SEMI_tok");}
	| RETURN_tok expression SEMI_tok {
		JumpNode* tmp = new JumpNode("jump_statement_",4);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("jump_statement : RETURN_tok expression SEMI_tok");}
	;

expression
	: assignment_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("expression : assignment_expression");}
	| expression COMMA_tok assignment_expression {
		DataNode* tmp = new DataNode("expresion_");
		tmp->setOperator(COMMA_OP);
		tmp->notData();
		tmp->setNumberChildren(2);
		//tmp->setTypeSpecifier(typeCheck(COMMA_OP, &$<tnode>1, &$<tnode>3));
		tmp->assignChild(0, $<tnode>1);
		tmp->assignChild(1, $<tnode>3);
		tmp->errorCheck();
		outputReduction("expression : expression COMMA_tok assignment_expression");}
	;

assignment_expression
	: conditional_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("assignment_expression : conditional_expression");}
	| unary_expression assignment_operator assignment_expression {
		AssignmentNode *tmp = new AssignmentNode("assignment_expression_",2);
		tmp->setAssignType(AssignType($<aType>2));
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		tmp->errorCheck();
		$<tnode>$ = tmp;
		outputReduction("assignment_expression : unary_expression assignment_operator assignment_expression");}
	;

assignment_operator
	: EQUAL_tok {
		$<aType>$ = EQUAL_ASSIGN;
		outputReduction("assignment_operator : EQUAL_tok");}
	| MULT_ASSIGN_tok {
		$<aType>$ = MULT_ASSIGN;
		outputReduction("assignment_operator : MULT_ASSIGN_tok");}
	| DIV_ASSIGN_tok {
		$<aType>$ = DIV_ASSIGN;
		outputReduction("assignment_operator : DIV_ASSIGN_tok");}
	| MOD_ASSIGN_tok {
		$<aType>$ = MOD_ASSIGN;
		outputReduction("assignment_operator : MOD_ASSIGN_tok");}
	| ADD_ASSIGN_tok {
		$<aType>$ = ADD_ASSIGN;
		outputReduction("assignment_operator : ADD_ASSIGN_tok ");}
	| SUB_ASSIGN_tok {
		$<aType>$ = SUB_ASSIGN;
		outputReduction("assignment_operator : SUB_ASSIGN_tok");}
	| LEFT_ASSIGN_tok {
		$<aType>$ = LEFT_ASSIGN;
		outputReduction("assignment_operator : LEFT_ASSIGN_tok");}
	| RIGHT_ASSIGN_tok {
		$<aType>$ = DIV_ASSIGN;
		outputReduction("assignment_operator : RIGHT_ASSIGN_tok");}
	| AND_ASSIGN_tok {
		$<aType>$ = AND_ASSIGN;
		outputReduction("assignment_operator : AND_ASSIGN_tok");}
	| XOR_ASSIGN_tok {
		$<aType>$ = XOR_ASSIGN;
		outputReduction("assignment_operator : XOR_ASSIGN_tok");}
	| OR_ASSIGN_tok {
		$<aType>$ = OR_ASSIGN;
		outputReduction("assignment_operator : OR_ASSIGN_tok");}
	;

conditional_expression
	: logical_or_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("conditional_expression : logical_or_expression");}
	| logical_or_expression QUESTION_MARK_tok expression COLON_tok conditional_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(QUESTION_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(3);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		tmp->assignChild(2,$<tnode>5);
		$<tnode>$ = tmp;
		outputReduction("conditional_expression : logical_or_expression QUESTION_MARK_tok expression COLON_tok conditional_expression");}
	;

constant_expression
	: conditional_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("constant_expression : conditional_expression");}
	;

logical_or_expression
	: logical_and_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("logical_or_expression : logical_and_expression");}
	| logical_or_expression OR_OP_tok logical_and_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(OR_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("logical_or_expression : logical_or_expression OR_OP_tok logical_and_expression");}
	;

logical_and_expression
	: inclusive_or_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("logical_and_expression : inclusive_or_expression");}
	| logical_and_expression AND_OP_tok inclusive_or_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(AND_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("logical_and_expression : logical_and_expression AND_OP_tok inclusive_or_expression");}
	;

inclusive_or_expression
	: exclusive_or_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("inclusive_or_expression : exclusive_or_expression");}
	| inclusive_or_expression BAR_tok exclusive_or_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(BAR_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("inclusive_or_expression : inclusive_or_expression BAR_tok exclusive_or_expression");}
	;

exclusive_or_expression
	: and_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("exclusive_or_expression : and_expression ");}
	| exclusive_or_expression CARET_tok and_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(CARET_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("exclusive_or_expression : exclusive_or_expression CARET_tok and_expression");}
	;

and_expression
	: equality_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("and_expression : equality_expression");}
	| and_expression AMP_tok equality_expression {
		DataNode* tmp = new DataNode("conditional_expression_");
		tmp->setOperator(AMP_OP);
		tmp->setTypeSpecifier(INT_TYPE_NODE);
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("and_expression : and_expression AMP_tok equality_expression");}
	;

equality_expression
	: relational_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("equality_expression : relational_expression");}
	| equality_expression EQ_OP_tok relational_expression {
		$<tnode>$ = createRelationNode(EQ_OP, $<tnode>1, $<tnode>3);
		outputReduction("equality_expression : equality_expression EQ_OP_tok relational_expression");}
	| equality_expression NE_OP_tok relational_expression {
		$<tnode>$ = createRelationNode(NE_OP, $<tnode>1, $<tnode>3);
		outputReduction("equality_expression : equality_expression NE_OP_tok relational_expression");}
	;

relational_expression
	: shift_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("relational_expression : shift_expression");}
	| relational_expression LT_tok shift_expression {
		$<tnode>$ = createRelationNode(LT_OP, $<tnode>1, $<tnode>3);
		outputReduction("relational_expression : relational_expression LT_tok shift_expression");}
	| relational_expression GT_tok shift_expression {
		$<tnode>$ = createRelationNode(GT_OP, $<tnode>1, $<tnode>3);
		outputReduction("relational_expression : relational_expression GT_tok shift_expression");}
	| relational_expression LE_OP_tok shift_expression {
		$<tnode>$ = createRelationNode(LE_OP, $<tnode>1, $<tnode>3);
		outputReduction("relational_expression : relational_expression LE_OP_tok shift_expression");}
	| relational_expression GE_OP_tok shift_expression {
		$<tnode>$ = createRelationNode(GE_OP, $<tnode>1, $<tnode>3);
		outputReduction("relational_expression : relational_expression GE_OP_tok shift_expression");}
	;

shift_expression
	: additive_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("shift_expression : additive_expression");}
	| shift_expression LEFT_OP_tok additive_expression {
		TreeNode* tmp = new TreeNode("shift_expression_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("shift_expression : shift_expression LEFT_OP_tok additive_expression");}
	| shift_expression RIGHT_OP_tok additive_expression {
		TreeNode* tmp = new TreeNode("shift_expression_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("shift_expression : shift_expression RIGHT_OP_tok additive_expression");}
	;

additive_expression
	: multiplicative_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("additive_expression : multiplicative_expression");}
	| additive_expression PLUS_tok multiplicative_expression {
		$<tnode>$ = createOperatorDataNode(ADD_OP, $<tnode>1,$<tnode>3);
		outputReduction("additive_expression : additive_expression PLUS_tok multiplicative_expression");}
	| additive_expression MINUS_tok multiplicative_expression {
		$<tnode>$ = createOperatorDataNode(SUB_OP, $<tnode>1,$<tnode>3);
		outputReduction("additive_expression : additive_expression MINUS_tok multiplicative_expression");}
	;

multiplicative_expression
	: cast_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("multiplicative_expression : cast_expression");}
	| multiplicative_expression STAR_tok cast_expression {
		$<tnode>$ = createOperatorDataNode(MULT_OP, $<tnode>1,$<tnode>3);				
		outputReduction("multiplicative_expression : multiplicative_expression STAR_tok cast_expression");}
	| multiplicative_expression DIV_tok cast_expression {
		// Might need to cast if data types of children different
		$<tnode>$ = createOperatorDataNode(DIV_OP, $<tnode>1,$<tnode>3);		
		outputReduction("multiplicative_expression : multiplicative_expression DIV_tok cast_expression");}
	| multiplicative_expression PERCENT_tok cast_expression {
		$<tnode>$ = createOperatorDataNode(MOD_OP, $<tnode>1,$<tnode>3);		
		outputReduction("multiplicative_expression : multiplicative_expression PERCENT_tok cast_expression");}
	;

cast_expression
	: unary_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("cast_expression : unary_expression");}
	| OPEN_PAREN_tok type_name CLOSE_PAREN_tok cast_expression {
		CastNode *tmp = new CastNode("cast_expression");
		tmp->assignChild(0,$<tnode>4);
		$<tnode>$ = tmp; 
		outputReduction("cast_expression : OPEN_PAREN_tok type_name CLOSE_PAREN_tok cast_expression");}
	;

unary_expression
	: postfix_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("unary_expression : postfix_expression");}
	| INC_OP_tok {} unary_expression {
		OperatorNode* tmp = new OperatorNode("unary_expression_", INC_op, 1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("unary_expression : INC_OP_tok unary_expression");}
	| DEC_OP_tok unary_expression {
		OperatorNode* tmp = new OperatorNode("unary_expression_", DEC_op, 1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("unary_expression : DEC_OP_tok unary_expression");}
	| unary_operator cast_expression {
		$<tnode>$ = $<tnode>1;
		$<tnode>$->assignChild(0,$<tnode>2);
		outputReduction("unary_expression : unary_operator cast_expression");}
	| SIZEOF_tok unary_expression {
		TreeNode* tmp = new TreeNode("unary_expression_",1);
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("unary_expression : SIZEOF_tok unary_expression");}
	| SIZEOF_tok OPEN_PAREN_tok type_name CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("unary_expression_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("unary_expression : SIZEOF_tok OPEN_PAREN_tok type_name CLOSE_PAREN_tok");}
	;

unary_operator
	: AMP_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", AMP_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : AMP_tok");}
	| STAR_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", STAR_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : STAR_tok");}
	| PLUS_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", PLUS_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : PLUS_tok");}
	| MINUS_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", MINUS_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : MINUS_tok");}
	| TILDA_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", TILDA_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : TILDA_tok");}
	| NOT_tok {
		OperatorNode* tmp = new OperatorNode("unary_operator_", NOT_op,1);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("unary_operator : NOT_tok");}
	;

postfix_expression
	: primary_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("postfix_expression : primary_expression");}
	| postfix_expression OPEN_BRACKET_tok expression CLOSE_BRACKET_tok {
		DataNode* tmp = new DataNode("postfix_expression_");
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		tmp->setTypeSpecifier(ID_TYPE_NODE);
		tmp->setOperator(BRACKET_OP);
		vector<nodeDataType> type;
		type.push_back($<tnode>1->getidDataType());
		tmp->setidDataTypes(type);
		tmp->notData();
		char useless[500];
		if($<tnode>3->getDataType(useless) != INT_TYPE_NODE)
		{
			if($<tnode>3->getDataType(useless) == ID_TYPE_NODE)
			{
				if($<tnode>3->getidDataType() != INT_TYPE_NODE)
				{
					yyerror("Invalid operand to [] operator");
				}
			}
			else
				yyerror("Invalid operand to [] operator");
		}
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression OPEN_BRACKET_tok expression CLOSE_BRACKET_tok");}
	| postfix_expression OPEN_PAREN_tok CLOSE_PAREN_tok {
		DataNode* tmp = new DataNode("postfix_expression_");
		EmptyNode* blank1 = new EmptyNode("empty_");
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setNumberChildren(2);

		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,blank1);
		tmp->setTypeSpecifier(ID_TYPE_NODE);
		tmp->setOperator(PAREN_OP);
		vector<nodeDataType> type;
		//cout << "hereE" <<  $<tnode>1->getidDataType() << endl;
		type.push_back($<tnode>1->getidDataType());
		tmp->setidDataTypes(type);
		tmp->notData();
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression OPEN_PAREN_tok CLOSE_PAREN_tok");}
	| postfix_expression OPEN_PAREN_tok argument_expression_list CLOSE_PAREN_tok {
		DataNode* tmp = new DataNode("postfix_expression_");
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->setNumberChildren(2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		tmp->setTypeSpecifier(ID_TYPE_NODE);
		tmp->setOperator(PAREN_OP);
		vector<nodeDataType> type;
		//cout << "hereE" <<  $<tnode>1->getidDataType() << endl;
		type.push_back($<tnode>1->getidDataType());
		tmp->setidDataTypes(type);
		tmp->notData();
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression OPEN_PAREN_tok argument_expression_list CLOSE_PAREN_tok");}
	| postfix_expression PERIOD_tok identifier {
		TreeNode* tmp = new TreeNode("postfix_expression_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression PERIOD_tok identifier");}
	| postfix_expression PTR_OP_tok identifier {
		TreeNode* tmp = new TreeNode("postfix_expression_",2);
		tmp->assignChild(0,$<tnode>1);
		tmp->assignChild(1,$<tnode>3);
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression PTR_OP_tok identifier");}
	| postfix_expression INC_OP_tok {
		TreeNode* tmp = new TreeNode("postfix_expression_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression INC_OP_tok");}
	| postfix_expression DEC_OP_tok {
		TreeNode* tmp = new TreeNode("postfix_expression_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>1);
		$<tnode>$ = tmp;
		outputReduction("postfix_expression : postfix_expression DEC_OP_tok");}
	;

primary_expression
	: identifier {
		$<tnode>$ = $<tnode>1;
		outputReduction("primary_expression : identifier");}
	| constant {
		$<tnode>$ = $<tnode>1;
		outputReduction("primary_expression : constant");}
	| string {
		$<tnode>$ = $<tnode>1;
		outputReduction("primary_expression : string");}
	| OPEN_PAREN_tok expression CLOSE_PAREN_tok {
		TreeNode* tmp = new TreeNode("primary_expression_",1);
		tmp->assignLine(line,column-size,column,codeLine());
		tmp->assignChild(0,$<tnode>2);
		$<tnode>$ = tmp;
		outputReduction("primary_expression : OPEN_PAREN_tok expression CLOSE_PAREN_tok");}
	;

argument_expression_list
	: assignment_expression {
		$<tnode>$ = $<tnode>1;
		outputReduction("argument_expression_list : assignment_expression");}
	| argument_expression_list COMMA_tok assignment_expression {
		DataNode* tmp = new DataNode("argument_expression_list_");
		tmp->setOperator(COMMA_OP);
		tmp->notData();
		tmp->setNumberChildren(2);


		tmp->assignChild(0, $<tnode>1);
		tmp->assignChild(1, $<tnode>3);
		//tmp->errorCheck();
		$<tnode>$ = tmp;
		outputReduction("argument_expression_list : argument_expression_list COMMA_tok assignment_expression");}
	;

constant
	: INTEGER_CONSTANT_tok {
		DataNode* tmp = new DataNode("constant_");
		tmp->storeInt(yylval.lint);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("constant : INTEGER_CONSTANT_tok");}
	| CHARACTER_CONSTANT_tok {
		DataNode* tmp = new DataNode("constant_");
		tmp->storeChar(yylval.lchar);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("constant : CHARACTER_CONSTANT_tok");}
	| FLOATING_CONSTANT_tok {
		DataNode* tmp = new DataNode("constant_");
		tmp->storeDouble(yylval.ldoub);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("constant : FLOATING_CONSTANT_tok");}
	| ENUMERATION_CONSTANT_tok {
		TreeNode* tmp = new TreeNode("constant",0);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("constant : ENUMERATION_CONSTANT_tok");}
	;

string
	: STRING_LITERAL_tok {
		DataNode* tmp = new DataNode("string_");
		tmp->storeString(yylval.lstr);
		tmp->assignLine(line,column-size,column,codeLine());
		$<tnode>$ = tmp;
		outputReduction("string : STRING_LITERAL_tok");}
	;

identifier
	: ID_tok {
		DataNode* tmp = new DataNode("identifier_");
		if (yylval.lnode != NULL) {

			/*printf("%s\n",yylval.lnode->name.c_str());
			tmp->storeString((char*)yylval.lnode->name.c_str());
			printf("%s\n",variableToInsert->name.c_str());*/

			if(insert_lookup == 0)
			{
				//cout << "am i here?" << endl;
				tmp->storeString((char*)variableToInsert->name.c_str());
				//variableToInsert->ticketNumber = tmp->returnTicket();
			}
			else
			{
				int q;

				Node *n = s.searchAll(yylval.lnode->name,&q);
				//cout << "ever here?" << endl;
				//Node *w = astTable.searchAll(yylval.lnode->name);
				//n->print();
				if(n!=NULL)
				{
					//need to use same ticket counter as the symbol table entry rather than making a new ticket for each i = 5; etc after declaration
					tmp->storeString((char*)yylval.lnode->name.c_str());
					tmp->setidDataTypes(n->types);
					cout << n->ticketNumber << endl;
					tmp->setTicketNumber(n->ticketNumber);
					//cout << yylval.lnode->name << tmp->getidDataType() << endl;
				}			
			}
		}
		else
		{	
			tmp->storeString((char*)"error");
			yyerror("Variable not declared before use");
		}
		tmp->setTypeSpecifier(ID_TYPE_NODE);
		tmp->assignLine(line,column-size,column,codeLine());
		
		$<tnode>$ = tmp;
		outputReduction("identifier : ID_tok");}
	;
%%

#include <stdio.h>
int lex_debug_level;
int symbol_table_debug;
int yacc_debug_level;
int c_line_lex_debug_level;
int c_line_symbol_table_debug;
int c_line_yacc_debug_level;


// logName = "compilerLog.txt";

extern FILE* yyin;


int main(int argc, char **argv)
{
	
	scopeInits = new TreeNode("scope_inits",1);
	
	blank = new EmptyNode("scope_empty");
	blank->assignLine(0,0,0,"  ");
	//printf("Entered Main\n");
	int scan_count = 0;
	int lex_count = 0;
	int yacc_count = 0;
	insert_lookup = 0;

	Label_counter = 0;
	AST_node_counter = 0;
	Variable_counter = 0;
	
	lex_debug_level=1;
	symbol_table_debug=1;
	yacc_debug_level=1;
	c_line_symbol_table_debug =1;
	c_line_lex_debug_level=1;
	c_line_yacc_debug_level=1;
	
	bool genAST=true;
	bool gen3AC=true;
	bool genAssembly = false;
	
	levels[0] = 2;
	levels[1] = 3;
	levels[2] = 5;
	levels[3] = 7;
	levels[4] = 11;
	
	scopeInits->assignChild(0,blank);
	cout<<"Here"<<endl;
	cout.flush();
	
	outfile = fopen("testCases/out.s","w");
	out_log = fopen(logName,"w");
	fprintf(out_log,"Log Start\n");
	fprintf(out_log,"\n");
	tokenFile = fopen("testCases/tokenFile.txt","w");
	parseFile = fopen("testCases/parseFile.txt","w");
	//productionFile = fopen("productionFile.txt","w");
	
	//printf("Created Log file\n");
	if(argc==1)
	{
		printf("No File Provided. Pass file in command line.");
	}
	else
	{
		if(!(yyin=fopen(argv[argc-1],"r")))
		{
			perror(argv[argc-1]);
			return(1);
		}
		file_name=argv[argc-1];
		errorText = fopen(argv[argc-1],"r");
		for(int i=argc-1; i>=1; i--)
		{
			if(argv[i][0]=='-' && argv[i][1]=='o')
			{
				fclose(parseFile);
				printf("%s\n",argv[i+1]);
				//outfile = fopen(argv[i+1],"w");
				parseFile = fopen(argv[i+1],"w");

			}
			if(argv[i][0]=='-' && argv[i][1]=='t')
			{
				fclose(tokenFile);
				printf("%s\n",argv[i+1]);
				tokenFile = fopen(argv[i+1],"w");

			}
			
			if(argv[i][0]=='-' && argv[i][1]=='a')
			{
				genAST = true;
			}
			
			if(argv[i][0]=='-' && argv[i][1]=='q')
			{
				gen3AC = true;
			}
			
			if(argv[i][0]=='-' && argv[i][1]=='S')
			{
				genAssembly=true;
			}
			
			if(argv[i][0]=='-' && argv[i][1]=='l')
			{
				fclose(out_log);
				out_log = fopen(argv[i+1],"w");
				fprintf(out_log,"Log Start\n");
				fprintf(out_log,"\n");
				logName = argv[i+1];
			}
			if(argv[i][0]=='-' && argv[i][1]=='d')
			{
				for(int p = 2;argv[i][p]!='\0';p++)
				{
					switch(argv[i][p])
					{
						case 'l':
							lex_count+=1;
							if(lex_count <= 5)
							{
								c_line_lex_debug_level *= levels[lex_count-1];
							}
							break;
						case 's':
							scan_count+=1;
							if(scan_count <= 5)
							{
								c_line_symbol_table_debug *= levels[scan_count-1];
							}
							break;
						case 'p':
							yacc_count+=1;
							if(yacc_count <= 5)
							{
								c_line_yacc_debug_level*=levels[yacc_count-1];
							}
							if(yacc_count == 3)
							{
								yydebug=1;
							}
							break;
					}
				}
				//printf("Lex Count: %d, Scan Count: %d\n",lex_count,scan_count);
				//printf("Lex Debug level: %d\nYacc Debug level: %d\nScanner Debug level: %d\n",c_line_lex_debug_level,c_line_yacc_debug_level,c_line_symbol_table_debug);
				
				lex_debug_level = c_line_lex_debug_level;
				//printf("Debug lex level %d\n",lex_debug_level);
				symbol_table_debug = c_line_symbol_table_debug;
				//printf("Debug symbol_table level %d\n",symbol_table_debug);
				yacc_debug_level = c_line_yacc_debug_level;
				//printf("Debug yacc level %d\n",yacc_debug_level);
			}
			
			
		}
	}
	yyparse();
	genAST = true;
	if(genAST)
	{
	AST.tree_to_gv("graphs/default.gv");
	}
	if(gen3AC)
	{
		
	AST.tree_to_3ac("build/3ac.txt");
	}
	if(genAssembly)
	{
		
	}
	//while((tok = yylex()))
	//{
	
		//printf("%d\n",tok);
	//}
	fclose(out_log);
	fclose(outfile);
	fclose(errorText);
	fclose(parseFile);
	fclose(tokenFile);
	return 0;	
}


void yyerror(char const *msg)
{
	char tmp[MAX_LINE_LENGTH];
	long int offset = ftell(errorText);
	fgets(tmp,sizeof tmp, errorText);
	fseek(errorText,offset,SEEK_SET);
	printf("ERROR: %s:Line: %d Column: %d %s\n",file_name,line,column,msg);
	printf("%s",tmp);
	for(int i = column-1; i>0;i--)
	{
		printf("-");
	}
	printf("^ \n\n");
	fprintf(stderr,"%s\n",msg);
	
	fprintf(out_log,"ERROR: %s:Line: %d Column: %d %s\n",file_name,line,column,msg);
	fprintf(out_log,"%s",tmp);
	for(int i = column-1; i>0;i--)
	{
		fprintf(out_log,"-");
	}
	fprintf(out_log,"^ \n\n");
}

// Given a type return a datatype
string getDataTypeString(nodeDataType type)
{
	switch (type) {
		case INT_TYPE_NODE:
			return("int");
		case DOUBLE_TYPE_NODE:
			return("double");
		case CHAR_TYPE_NODE:
			return("char");
		case VOID_TYPE_NODE:
			return("void");
		case POINTER_TYPE_NODE:
			return("*");
		case SHORT_TYPE_NODE:
			return("short");
		case LONG_TYPE_NODE:
			return("long");
		case FLOAT_TYPE_NODE:
			return("float");
		case SIGNED_TYPE_NODE:
			return("signed");
		case UNSIGNED_TYPE_NODE:
			return("unsigned");
		case STRUCT_TYPE_NODE:
			return("struct");
		case UNION_TYPE_NODE:
			return("union");
		case ENUM_TYPE_NODE:
			return("enum");
		case TYPEDEF_NAME_TYPE_NODE:
			return("typedef");
		case CONST_TYPE_NODE:
			return("const");
		case VOLATILE_TYPE_NODE:
			return("volatile");
		case AUTO_TYPE_NODE:
			return("auto");
		case REGISTER_TYPE_NODE:
			return("register");
		case STATIC_TYPE_NODE:
			return("static");
		case EXTERN_TYPE_NODE:
			return("extern");
		case TYPEDEF_TYPE_NODE:
			return("typedef");
		case ID_TYPE_NODE:
			return("id");
		default:
			return("ERROR");
	}
}

TreeNode* createOperatorDataNode(OperatorType opType, TreeNode *leftChild, TreeNode* rightChild)
{
		DataNode* tmp = new DataNode("operator_expression_");
		tmp->setOperator(opType);
		tmp->notData();
		tmp->setNumberChildren(2);

		//tmp->setTypeSpecifier(typeCheck(opType, &leftChild, &rightChild));

		//cout << leftChild->returnTicket() << endl;
		tmp->assignChild(0, leftChild);
		tmp->assignChild(1, rightChild);
		tmp->errorCheck();
		return tmp;
}
TreeNode* createRelationNode(OperatorType opType, TreeNode *leftChild, TreeNode *rightChild)
{

		RelationNode* tmp = new RelationNode("equality_expression_");
		tmp->setOperator(opType);
		//tmp->setTypeSpecifier(typeCheck(opType, &leftChild, &rightChild));
		tmp->assignChild(0,leftChild);
		tmp->assignChild(1,rightChild);
		tmp->errorCheck();
		return tmp;
}
void outputReduction(const char *production)
{	
	//fprintf(out_log, "%s", s);
	time_time = time(NULL);
	clock_time = clock();
	if(yacc_debug_level%2==0 || yacc_debug_level%3==0 || yacc_debug_level%7==0 )
	{
		fprintf(parseFile,"%s PARSER Time::%ld:%ld\t Line: %d\t",file_name, time_time,clock_time,line);
		printf("%s PARSER Time::%ld:%ld\t",file_name, time_time,clock_time);
	}
	//printf("%ld:%ld ",time_time,clock_time);

	if(yacc_debug_level%2==0)
	{
		fprintf(parseFile,"%s\n",production);
		printf("%s\n",production);
	}
	
}

string codeLine()
{
	string ret;
	char atmp[500];
	long int offset = ftell(errorText);
	fgets(atmp,sizeof atmp, errorText);
	fseek(errorText,offset,SEEK_SET);
	ret.assign(atmp);
	return ret;
}
